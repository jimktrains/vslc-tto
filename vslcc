#!/usr/bin/env python3

import argparse
import sys
import os.path
import struct

bytecode = [0xff] * 1024



parser = argparse.ArgumentParser(
                    prog='vslcc',
                    description='VSLC Compiler',
                    epilog='')

parser.add_argument('filename')

args = parser.parse_args()


outfile = os.path.splitext(args.filename)[0] + ".eeprom.bin"

instr_opcode = {
"PUSH": 0x00,
"POP": 0x10,
"SET": 0x20,
"RESET": 0x30,
"NOP": 0xff,
"CLR": 0xf0,
"SETALL": 0xf1,
"RISING": 0b11000000,
"FALLING": 0b11010000,
"SWAP": 0b11110010,
"ROT": 0b11110011,

"AND": 0b10010001,
"NAND": 0b10011110,
"OR": 0b10010111,
"NOR": 0b10011000,
"XOR": 0b10010110,
"BICOND": 0b10011001,
"IMPL": 0b10011101,
"NIMPL": 0b10010010,
"CONV": 0b10011011,
"NCONV": 0b10010100,

"DUP": 0b10111100,
"OVER": 0b10111010,
"DROP": 0b10011010,
"ZERO": 0b10110000,
"ONE": 0b10111111,
"NOT": 0b10010011,
"OVERNOT": 0b10010101,
}


cur_addr = 4
with open(args.filename, 'r') as f:
    for line in f:
        line = line.strip()
        if len(line) == 0:
            continue
        if line.startswith('#'):
            continue
        line = line.upper()
        line = line.split(' ')
        opcode = 0xff
        reg = 0
        line[0] = line[0].upper()
        if line[0] not in instr_opcode:
            print(f"{line} not found as an opcode", file=sys.stderr)
            sys.exit(1)
        opcode = instr_opcode[line[0]] 
        if len(line) > 1:
            if line[1].startswith('S'):
                reg = 0x40 + int(line[1][1])
            elif line[1].startswith('I'):
                reg = int(line[1][1])
            elif line[1].startswith('O'):
                reg = 8 + int(line[1][1])
            else:
                print(f"{line[1]} is an unknown register", file=sys.stderr)
                sys.exit(2)

        bytecode[cur_addr] = opcode + reg
        print(f"{cur_addr=:02x} {line=} => {opcode=:02x} {reg=:02x} => {bytecode[cur_addr]:02x}({bytecode[cur_addr]:08b})")
        cur_addr += 1

start_addr = struct.pack('>h', 4)
bytecode[0] = start_addr[0]
bytecode[1] = start_addr[1]

end_addr = struct.pack('>h', cur_addr - 1)
bytecode[2] = end_addr[0]
bytecode[3] = end_addr[1]

print(f"{start_addr=} {end_addr=}")


with open(outfile, "wb") as f:
    f.write(bytes(bytecode))
