#!/usr/bin/env python3

import argparse
import sys
import os.path
import struct

bytecode = [0xff] * 1024



parser = argparse.ArgumentParser(
                    prog='vslcc',
                    description='VSLC Compiler',
                    epilog='')

parser.add_argument('filename')

args = parser.parse_args()


outfile = os.path.splitext(args.filename)[0] + ".eeprom.bin"

SHIFT_0     = 0b00000000
SHIFT_L1    = 0b00110000
SHIFT_R1    = 0b00010000

INSTR_LOGIC = 0b10000000

instr_opcode = {
"PUSH": 0x00,
"POP": 0x10,
"SET": 0x20,
"RESET": 0x30,
"NOP": 0xff,
"CLR": 0xf0,
"SETALL": 0xf1,
"RISING": 0b11000000,
"FALLING": 0b11010000,
"SWAP": 0b11110010,
"ROT": 0b11110011,

"AND"     : INSTR_LOGIC + SHIFT_R1 + 0b00000001,
"NIMPL"   : INSTR_LOGIC + SHIFT_R1 + 0b00000010,
"NCONV"   : INSTR_LOGIC + SHIFT_R1 + 0b00000100,
"DROP"    : INSTR_LOGIC + SHIFT_R1 + 0b00000101,
"XOR"     : INSTR_LOGIC + SHIFT_R1 + 0b00000110,
"OR"      : INSTR_LOGIC + SHIFT_R1 + 0b00000111,
"NOR"     : INSTR_LOGIC + SHIFT_R1 + 0b00001000,
"BICOND"  : INSTR_LOGIC + SHIFT_R1 + 0b00001001,
"NOT"     : INSTR_LOGIC + SHIFT_R1 + 0b00001010,
"OVERNOT" : INSTR_LOGIC + SHIFT_R1 + 0b00001010,
"CONV"    : INSTR_LOGIC + SHIFT_R1 + 0b00001011,
"IMPL"    : INSTR_LOGIC + SHIFT_R1 + 0b00001101,
"NAND"    : INSTR_LOGIC + SHIFT_R1 + 0b00001110,

"DUP"     : INSTR_LOGIC + SHIFT_L1 + 0b00000101,
"OVER"    : INSTR_LOGIC + SHIFT_L1 + 0b00001010,
"ZERO"    : INSTR_LOGIC + SHIFT_L1 + 0b00000000,
"ONE"     : INSTR_LOGIC + SHIFT_L1 + 0b00001111,
}


cur_addr = 4
with open(args.filename, 'r') as f:
    for line in f:
        line = line.strip()
        if len(line) == 0:
            continue
        if line.startswith('#'):
            continue
        line = line.upper()
        line = line.split(' ')
        opcode = 0xff
        reg = 0
        line[0] = line[0].upper()
        if line[0] not in instr_opcode:
            print(f"{line} not found as an opcode", file=sys.stderr)
            sys.exit(1)
        opcode = instr_opcode[line[0]] 
        if len(line) > 1:
            if line[1].startswith('S'):
                reg = 0x40 + int(line[1][1])
            elif line[1].startswith('I'):
                reg = int(line[1][1])
            elif line[1].startswith('O'):
                reg = 8 + int(line[1][1])
            else:
                print(f"{line[1]} is an unknown register", file=sys.stderr)
                sys.exit(2)

        bytecode[cur_addr] = opcode + reg
        print(f"{cur_addr=:02x} {line=} => {opcode=:02x} {reg=:02x} => {bytecode[cur_addr]:02x}({bytecode[cur_addr]:08b})")
        cur_addr += 1

start_addr = struct.pack('>h', 4)
bytecode[0] = start_addr[0]
bytecode[1] = start_addr[1]

end_addr = struct.pack('>h', cur_addr - 1)
bytecode[2] = end_addr[0]
bytecode[3] = end_addr[1]

print(f"{start_addr=} {end_addr=}")


with open(outfile, "wb") as f:
    f.write(bytes(bytecode))
