* General Description

- 4 bit nibbles as processor word size
- 1 bit databus
- stack machine
  - stack is cleared on cycle start
  - code executes until a cycle start happens or the end of code memory is
    reached, in which case a new cycle is started
- When in reset, you can shift data into the code memory
- 8 input bits/registers mapped to pins
- 8 output bits/registers mapped to pins
- 1 error bit mapped to a pin (Not implemented yet)
- X bit data stack (let's see how big it can be made?) (32bits, currently)
- X nibble code memory (32 nibbles, currently)
- 1 16-bit timer/counter with clock divisor (not implemented yet)
- 1 main clock divisor (to take the system/instruction clock to a cycle
  clock) (not implemented yet)

* Opcodes
  ** Implemented

#+BEGIN_SRC
PUSH reg              0000 RRRR
POP  reg              0001 1RRR
SET  reg              0010 1RRR
RESET reg             0011 1RRR
POP TIMER             0001 0XXX
SET TIMER             0010 0XXX
RESET TIMER           0011 0XXX

nos          0011
tos          0101
           shift once
          shift twice
AND     1010 0001
NAND    1010 1110
OR      1010 0111
NOR     1010 1000
XOR     1010 0110
BICOND  1010 1001
IMPL    1010 1101
NIMPL   1010 0010
CONV    1010 1011
NCONV   1010 0100

DUP     1000 1100
OVER    1000 1010
DROP    1010 1010
ZERO    1000 0000
ONE     1000 1111
NOT     1001 0011
OVERNOT 1010 0101

CLR     1111 0000
SETALL  1111 0001
NOP     1111 1111

SETUP TIMER PA period 0111 0000 PPPP PPPP PPPP PPPP P=period
SETUP TIMER PB period 0111 0001 PPPP PPPP PPPP PPPP P=period
SETUP TIMER M mode    0100 000M M=cycle/one-shot
SETUP TIMER CLOCKDIV  0101 DDDD D=log2(clock divisor)

RISING     1110 0RRR
FALLING    1110 1RRR

STACK SWAP 1111 0010
STACK ROT  1111 0011
#+END_SRC

* Instruction Cycle

  -
